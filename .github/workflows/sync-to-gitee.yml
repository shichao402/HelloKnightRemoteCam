name: Sync Release to Gitee

# 当 GitHub Release 创建后，自动同步到 Gitee
on:
  release:
    types: [published]  # 当 Release 发布时触发
  workflow_call:  # 允许被其他工作流调用
    inputs:
      release_tag:
        description: '要同步的 Release 标签（例如：v1.0.7），留空则使用最新 Release'
        required: false
        type: string
  workflow_dispatch:  # 允许手动触发
    inputs:
      release_tag:
        description: '要同步的 Release 标签（例如：v1.0.7），留空则使用最新 Release'
        required: false
        type: string

jobs:
  sync-release:
    name: Sync Release to Gitee
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Check Gitee Secrets
        env:
          GITEE_REPO_OWNER: ${{ secrets.GITEE_REPO_OWNER }}
          GITEE_REPO_NAME: ${{ secrets.GITEE_REPO_NAME }}
        run: |
          echo "🔍 检查 Gitee Secrets 配置..."
          
          # 检查 GITEE_TOKEN（不显示明文）
          if [ -z "${{ secrets.GITEE_TOKEN }}" ]; then
            echo "❌ GITEE_TOKEN 未配置"
            exit 1
          else
            TOKEN_LEN=${#GITEE_TOKEN}
            TOKEN_PREFIX="${GITEE_TOKEN:0:4}"
            TOKEN_SUFFIX="${GITEE_TOKEN: -4}"
            echo "✅ GITEE_TOKEN 已配置 (长度: ${TOKEN_LEN}, 前缀: ${TOKEN_PREFIX}..., 后缀: ...${TOKEN_SUFFIX})"
          fi
          
          # 清理并显示 GITEE_REPO_OWNER（显示完整值，因为这不是敏感信息）
          GITEE_REPO_OWNER_CLEAN=$(printf '%s' "${GITEE_REPO_OWNER}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          if [ -z "${GITEE_REPO_OWNER_CLEAN}" ]; then
            echo "❌ GITEE_REPO_OWNER 未配置"
            exit 1
          else
            echo "✅ GITEE_REPO_OWNER 已配置: ${GITEE_REPO_OWNER_CLEAN}"
          fi
          
          # 清理并显示 GITEE_REPO_NAME（显示完整值，因为这不是敏感信息）
          GITEE_REPO_NAME_CLEAN=$(printf '%s' "${GITEE_REPO_NAME}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          if [ -z "${GITEE_REPO_NAME_CLEAN}" ]; then
            echo "❌ GITEE_REPO_NAME 未配置"
            exit 1
          else
            echo "✅ GITEE_REPO_NAME 已配置: ${GITEE_REPO_NAME_CLEAN}"
          fi
          
          GITEE_REPO="${GITEE_REPO_OWNER_CLEAN}/${GITEE_REPO_NAME_CLEAN}"
          echo "📦 Gitee 仓库: ${GITEE_REPO}"
          echo "✅ 所有 Gitee Secrets 配置检查通过"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Extract release tag (for finding release)
        id: get_release_tag
        run: |
          echo "🔍 提取 Release 标签（用于查找 Release）..."
          echo "  事件类型: ${{ github.event_name }}"
          echo "  GITHUB_REF: ${GITHUB_REF}"
          
          # 如果是 workflow_call（被其他工作流调用），使用输入的 release_tag
          if [ "${{ github.event_name }}" == "workflow_call" ]; then
            TAG_NAME="${{ inputs.release_tag }}"
            echo "📌 工作流调用: 使用标签 ${TAG_NAME}"
            echo "  [调试] inputs.release_tag 值: '${{ inputs.release_tag }}'"
            echo "  [调试] TAG_NAME 值: '${TAG_NAME}'"
          # 如果是手动触发，使用输入的 release_tag
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG_NAME="${{ github.event.inputs.release_tag }}"
            echo "📌 手动触发: 使用标签 ${TAG_NAME:-（未提供，将使用最新）}"
          else
            # 从 release 事件获取 tag 名称
            # release 事件的 GITHUB_REF 格式可能是 refs/tags/v1.0.0
            TAG_NAME=${GITHUB_REF#refs/tags/}
            echo "  [调试] 从 GITHUB_REF 提取: ${TAG_NAME}"
            
            # 如果没有从 GITHUB_REF 获取到，尝试从环境变量获取
            if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" == "$GITHUB_REF" ]; then
              # release 事件可能使用不同的 ref
              TAG_NAME=${GITHUB_REF#refs/heads/}
              echo "  [调试] 从 refs/heads/ 提取: ${TAG_NAME}"
            fi
            
            # 如果还是获取不到，从 GitHub API 获取
            if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" == "$GITHUB_REF" ]; then
              echo "  [调试] 从 GitHub API 获取最新 Release..."
              TAG_NAME=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/releases/latest" | \
                jq -r '.tag_name // empty')
              echo "  [调试] API 返回: ${TAG_NAME}"
            fi
          fi
          
          # 如果 TAG_NAME 为空，从 GitHub API 获取最新 Release
          if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" == "" ]; then
            echo "📡 未提供 Release 标签，从 GitHub API 获取最新 Release..."
            TAG_NAME=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/latest" | \
              jq -r '.tag_name // empty')
            
            if [ -n "$TAG_NAME" ] && [ "$TAG_NAME" != "null" ] && [ "$TAG_NAME" != "" ]; then
              echo "✅ 获取到最新 Release 标签: ${TAG_NAME}"
            else
              echo "❌ 无法从 GitHub API 获取最新 Release 标签"
              echo "  请手动指定 release_tag 参数，或确保仓库中至少有一个已发布的 Release"
              exit 1
            fi
          fi
          
          # 确保 TAG_NAME 不为空
          if [ -z "$TAG_NAME" ] || [ "$TAG_NAME" == "" ] || [ "$TAG_NAME" == "null" ]; then
            echo "❌ 无法获取 Release 标签"
            echo "  请手动指定 release_tag 参数，或确保仓库中至少有一个已发布的 Release"
            exit 1
          fi
          
          echo "TAG_NAME=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "✅ Release 标签: ${TAG_NAME}"
          echo ""
          echo "注意: 实际版本号将从构建产物中的 VERSION.yaml 提取"

      - name: Get Release info
        uses: actions/github-script@v7
        id: release_info
        with:
          script: |
            // 从 release 事件获取 release 信息
            let release;
            const tagName = '${{ steps.get_release_tag.outputs.TAG_NAME }}';
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            
            console.log(`🔍 获取 Release 信息:`);
            console.log(`  标签: ${tagName}`);
            console.log(`  仓库: ${repoOwner}/${repoName}`);
            console.log(`  事件类型: ${context.eventName}`);
            
            if (context.payload.release && context.eventName === 'release') {
              // release 事件直接包含 release 信息
              release = context.payload.release;
              console.log('✅ 从事件负载获取 Release 信息');
            } else {
              // 手动触发或其他情况，通过 API 获取
              const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/releases/tags/${tagName}`;
              console.log(`📡 通过 GitHub API 获取 Release 信息...`);
              console.log(`  API URL: ${apiUrl}`);
              
              try {
                const { data } = await github.rest.repos.getReleaseByTag({
                  owner: repoOwner,
                  repo: repoName,
                  tag: tagName
                });
                release = data;
                console.log(`✅ 成功获取 Release 信息`);
                console.log(`  Release ID: ${release.id}`);
                console.log(`  Release URL: ${release.html_url}`);
              } catch (error) {
                console.error(`❌ 获取 Release 失败:`);
                console.error(`  错误信息: ${error.message}`);
                console.error(`  HTTP 状态码: ${error.status || 'N/A'}`);
                core.setFailed(`Failed to get release for tag ${tagName}: ${error.message}`);
                throw error;
              }
            }
            
            // 显示 Release 详细信息
            console.log(`\n📋 Release 详细信息:`);
            console.log(`  ID: ${release.id}`);
            console.log(`  名称: ${release.name || release.tag_name}`);
            console.log(`  标签: ${release.tag_name}`);
            console.log(`  创建时间: ${release.created_at}`);
            console.log(`  发布时间: ${release.published_at || '未发布'}`);
            console.log(`  作者: ${release.author?.login || 'N/A'}`);
            console.log(`  URL: ${release.html_url}`);
            console.log(`  草稿: ${release.draft ? '是' : '否'}`);
            console.log(`  预发布: ${release.prerelease ? '是' : '否'}`);
            
            const assets = release.assets || [];
            console.log(`\n📦 找到 ${assets.length} 个构建产物:`);
            assets.forEach((asset, index) => {
              const sizeMB = (asset.size / 1024 / 1024).toFixed(2);
              const downloadCount = asset.download_count || 0;
              console.log(`  ${index + 1}. ${asset.name}`);
              console.log(`     大小: ${sizeMB} MB`);
              console.log(`     下载次数: ${downloadCount}`);
              console.log(`     下载 URL: ${asset.browser_download_url}`);
            });
            
            // 验证 Release 状态
            if (release.draft) {
              console.log('\n⚠️ 警告: Release 是草稿状态');
            }
            if (release.prerelease) {
              console.log('\n⚠️ 警告: Release 是预发布版本');
            }
            
            // 显示 Release 正文（前500字符）
            if (release.body) {
              const bodyPreview = release.body.length > 500 
                ? release.body.substring(0, 500) + '...' 
                : release.body;
              console.log(`\n📝 Release 正文预览:`);
              console.log(bodyPreview);
            }
            
            // 保存 release 信息
            core.setOutput('release_body', release.body || '');
            core.setOutput('release_name', release.name || release.tag_name);
            
            // 返回 assets 信息供后续步骤使用
            return JSON.stringify(assets.map(a => ({
              name: a.name,
              url: a.browser_download_url
            })));

      - name: Download assets files
        env:
          GH_TOKEN: ${{ github.token }}  # GitHub CLI 需要这个 token
        run: |
          TAG_NAME="${{ steps.get_release_tag.outputs.TAG_NAME }}"
          echo "📥 下载构建产物文件..."
          echo "  Release 标签: ${TAG_NAME}"
          
          mkdir -p release-assets
          echo "  目标目录: $(realpath release-assets)"
          
          # 使用 GitHub CLI 下载文件（如果可用）
          if command -v gh &> /dev/null; then
            echo "  使用 GitHub CLI 下载文件..."
            echo "  命令: gh release download \"${TAG_NAME}\" -D release-assets"
            
            DOWNLOAD_OUTPUT=$(gh release download "${TAG_NAME}" -D release-assets 2>&1)
            DOWNLOAD_EXIT_CODE=$?
            
            if [ $DOWNLOAD_EXIT_CODE -eq 0 ]; then
              echo "✅ GitHub CLI 下载完成"
            else
              echo "⚠️ GitHub CLI 下载可能失败 (退出码: ${DOWNLOAD_EXIT_CODE})"
              echo "  输出: ${DOWNLOAD_OUTPUT}"
            fi
          else
            # 手动下载（使用 curl）
            echo "  使用 curl 手动下载文件..."
            ASSETS='${{ steps.release_info.outputs.result }}'
            
            ASSET_COUNT=$(echo "$ASSETS" | jq 'length' 2>/dev/null || echo "0")
            echo "  需要下载 ${ASSET_COUNT} 个文件"
            
            DOWNLOAD_SUCCESS=0
            DOWNLOAD_FAILED=0
            
            echo "$ASSETS" | jq -r '.[] | "\(.url)|\(.name)"' | while IFS='|' read -r url name; do
              if [ -n "$url" ] && [ -n "$name" ]; then
                echo "  📦 下载 ${name}..."
                echo "    下载 URL: ${url}"
                
                DOWNLOAD_RESPONSE=$(curl -s -w "\n%{http_code}" -L \
                  -H "Authorization: token ${{ github.token }}" \
                  -o "release-assets/${name}" \
                  "${url}")
                
                HTTP_CODE=$(echo "$DOWNLOAD_RESPONSE" | tail -n1)
                
                if [ "$HTTP_CODE" = "200" ]; then
                  FILE_SIZE=$(du -h "release-assets/${name}" | cut -f1)
                  echo "    ✅ ${name} 下载成功 (${FILE_SIZE})"
                else
                  echo "    ❌ ${name} 下载失败 (HTTP ${HTTP_CODE})"
                fi
              fi
            done
          fi
          
          echo ""
          echo "📋 已下载的文件列表:"
          ls -lh release-assets/ || echo "  目录为空或不存在"
          
          FILE_COUNT=$(find release-assets -type f 2>/dev/null | wc -l)
          TOTAL_SIZE=$(du -sh release-assets 2>/dev/null | cut -f1 || echo "0")
          echo ""
          echo "  文件数量: ${FILE_COUNT}"
          echo "  总大小: ${TOTAL_SIZE}"

      - name: Extract VERSION.yaml from build tag and get versions
        id: get_version
        run: |
          # 从 Release 标签获取版本号
          TAG_NAME="${{ steps.get_release_tag.outputs.TAG_NAME }}"
          VERSION=${TAG_NAME#v}  # 去掉 v 前缀（例如 v1.0.7 -> 1.0.7）
          
          echo "🔍 从 build tag 读取 VERSION.yaml..."
          echo "  Release Tag: ${TAG_NAME}"
          echo "  Version: ${VERSION}"
          
          # 根据版本号构建 build tag 名称（例如 1.0.7 -> build1.0.7）
          BUILD_TAG="build${VERSION}"
          echo "  Build Tag: ${BUILD_TAG}"
          
          # Checkout build tag 以获取 VERSION.yaml
          git fetch --tags --force
          if git rev-parse "${BUILD_TAG}" >/dev/null 2>&1; then
            echo "✅ 找到 build tag: ${BUILD_TAG}"
            git checkout "${BUILD_TAG}" -- VERSION.yaml 2>/dev/null || {
              echo "⚠️ 无法 checkout VERSION.yaml，尝试从当前工作区读取"
              if [ ! -f "VERSION.yaml" ]; then
                echo "❌ 错误: 未找到 VERSION.yaml"
                exit 1
              fi
            }
          else
            echo "⚠️ 未找到 build tag: ${BUILD_TAG}"
            echo "  尝试从当前工作区读取 VERSION.yaml"
            if [ ! -f "VERSION.yaml" ]; then
              echo "❌ 错误: 未找到 VERSION.yaml，也无法找到 build tag"
              echo "  使用 Release 标签版本号: ${VERSION}"
              echo "TAG_NAME=${TAG_NAME}" >> $GITHUB_OUTPUT
              echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # 安装 PyYAML
          python3 -m pip install --user pyyaml --quiet || \
          python3 -c "import yaml" 2>/dev/null || python3 -m pip install pyyaml --quiet
          
          # 从 VERSION.yaml 读取版本信息
          CLIENT_FULL_VERSION=$(python3 -c "import yaml; print(yaml.safe_load(open('VERSION.yaml'))['client']['version'])")
          SERVER_FULL_VERSION=$(python3 -c "import yaml; print(yaml.safe_load(open('VERSION.yaml'))['server']['version'])")
          
          # 提取主版本号（去除build number）
          CLIENT_VERSION_NUM=$(echo "${CLIENT_FULL_VERSION}" | sed 's/+.*//')
          SERVER_VERSION_NUM=$(echo "${SERVER_FULL_VERSION}" | sed 's/+.*//')
          
          # 使用从 VERSION.yaml 提取的版本号（确保一致性）
          VERSION="${CLIENT_VERSION_NUM}"
          
          echo ""
          echo "✅ 从 build tag (${BUILD_TAG}) 的 VERSION.yaml 提取的版本信息:"
          echo "  Client Full Version: ${CLIENT_FULL_VERSION}"
          echo "  Client Version Number: ${CLIENT_VERSION_NUM}"
          echo "  Server Full Version: ${SERVER_FULL_VERSION}"
          echo "  Server Version Number: ${SERVER_VERSION_NUM}"
          echo "  Release Tag: ${TAG_NAME}"
          echo "  Release Version: ${VERSION}"
          
          # 输出版本号供后续步骤使用
          echo "TAG_NAME=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "CLIENT_FULL_VERSION=${CLIENT_FULL_VERSION}" >> $GITHUB_OUTPUT
          echo "SERVER_FULL_VERSION=${SERVER_FULL_VERSION}" >> $GITHUB_OUTPUT

      - name: Create Gitee Release
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          GITEE_REPO_OWNER: ${{ secrets.GITEE_REPO_OWNER }}
          GITEE_REPO_NAME: ${{ secrets.GITEE_REPO_NAME }}
        run: |
          TAG_NAME_RAW="${{ steps.get_version.outputs.TAG_NAME }}"
          RELEASE_NAME="${{ steps.release_info.outputs.release_name }}"
          RELEASE_BODY="${{ steps.release_info.outputs.release_body }}"
          
          # 清理 TAG_NAME：去除换行符、回车符和前后空格
          TAG_NAME=$(printf '%s' "${TAG_NAME_RAW}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # 清理并去除换行符、回车符和前后空格
          GITEE_REPO_OWNER=$(printf '%s' "${GITEE_REPO_OWNER}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          GITEE_REPO_NAME=$(printf '%s' "${GITEE_REPO_NAME}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # URL 编码
          GITEE_REPO_OWNER_ENCODED=$(printf '%s' "${GITEE_REPO_OWNER}" | jq -sRr @uri)
          GITEE_REPO_NAME_ENCODED=$(printf '%s' "${GITEE_REPO_NAME}" | jq -sRr @uri)
          TAG_NAME_ENCODED=$(printf '%s' "${TAG_NAME}" | jq -sRr @uri)
          GITEE_REPO="${GITEE_REPO_OWNER}/${GITEE_REPO_NAME}"
          
          echo "🚀 创建 Gitee Release..."
          echo "  标签: ${TAG_NAME}"
          echo "  名称: ${RELEASE_NAME}"
          echo "  仓库: ${GITEE_REPO}"
          echo "  Owner: ${GITEE_REPO_OWNER}"
          echo "  Repo Name: ${GITEE_REPO_NAME}"
          echo "  标签 (编码后): ${TAG_NAME_ENCODED}"
          
          # 验证仓库是否存在（获取默认分支信息）
          echo "🔍 验证 Gitee 仓库是否存在..."
          REPO_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}"
          echo "  API URL: ${REPO_API_URL}"
          
          REPO_CHECK=$(curl -s -w "\n%{http_code}" -X GET \
            -H "Authorization: token ${GITEE_TOKEN}" \
            "${REPO_API_URL}")
          
          REPO_CHECK_HTTP_CODE=$(echo "$REPO_CHECK" | tail -n1)
          REPO_CHECK_BODY=$(echo "$REPO_CHECK" | sed '$d')
          
          echo "  HTTP 状态码: ${REPO_CHECK_HTTP_CODE}"
          
          if [ "$REPO_CHECK_HTTP_CODE" != "200" ]; then
            ERROR_MSG=$(echo "$REPO_CHECK_BODY" | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "$REPO_CHECK_BODY")
            echo "❌ Gitee 仓库不存在或无法访问 (HTTP ${REPO_CHECK_HTTP_CODE})"
            echo "  API URL: ${REPO_API_URL}"
            echo "  错误信息: ${ERROR_MSG}"
            echo "  完整响应: ${REPO_CHECK_BODY}"
            echo ""
            echo "  请检查："
            echo "    1. GITEE_REPO_OWNER 是否正确: ${GITEE_REPO_OWNER}"
            echo "    2. GITEE_REPO_NAME 是否正确: ${GITEE_REPO_NAME}"
            echo "    3. GITEE_TOKEN 是否有访问该仓库的权限"
            exit 1
          fi
          
          REPO_FULL_NAME=$(echo "$REPO_CHECK_BODY" | jq -r '.full_name // empty' 2>/dev/null || echo "")
          REPO_DESCRIPTION=$(echo "$REPO_CHECK_BODY" | jq -r '.description // empty' 2>/dev/null || echo "")
          REPO_DEFAULT_BRANCH=$(echo "$REPO_CHECK_BODY" | jq -r '.default_branch // "master"' 2>/dev/null || echo "master")
          echo "✅ Gitee 仓库验证通过"
          if [ -n "$REPO_FULL_NAME" ]; then
            echo "  仓库全名: ${REPO_FULL_NAME}"
          fi
          if [ -n "$REPO_DESCRIPTION" ]; then
            echo "  仓库描述: ${REPO_DESCRIPTION}"
          fi
          echo "  默认分支: ${REPO_DEFAULT_BRANCH}"
          
          # 获取tag对应的commit SHA（用于创建Release，确保Release路径正确）
          echo ""
          echo "🔍 获取tag ${TAG_NAME} 对应的commit SHA..."
          TAG_INFO_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/tags/${TAG_NAME_ENCODED}"
          TAG_INFO=$(curl -s -w "\n%{http_code}" -X GET \
            -H "Authorization: token ${GITEE_TOKEN}" \
            "${TAG_INFO_API_URL}")
          
          TAG_INFO_HTTP_CODE=$(echo "$TAG_INFO" | tail -n1)
          TAG_INFO_BODY=$(echo "$TAG_INFO" | sed '$d')
          
          if [ "$TAG_INFO_HTTP_CODE" = "200" ]; then
            TARGET_COMMITISH=$(echo "$TAG_INFO_BODY" | jq -r '.commit.sha // empty' 2>/dev/null || echo "")
            if [ -n "$TARGET_COMMITISH" ] && [ "$TARGET_COMMITISH" != "null" ]; then
              echo "✅ 使用tag ${TAG_NAME} 对应的commit: ${TARGET_COMMITISH:0:7}..."
            else
              echo "⚠️ 无法从tag获取commit SHA，尝试使用默认分支"
              TARGET_COMMITISH=""
            fi
          else
            echo "⚠️ 无法获取tag信息，尝试使用默认分支"
            TARGET_COMMITISH=""
          fi
          
          # 如果无法从tag获取commit，则使用默认分支的最新commit
          if [ -z "$TARGET_COMMITISH" ] || [ "$TARGET_COMMITISH" == "null" ]; then
            echo "🔍 获取默认分支 ${REPO_DEFAULT_BRANCH} 的最新 commit..."
            BRANCH_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/branches/${REPO_DEFAULT_BRANCH}"
            BRANCH_CHECK=$(curl -s -w "\n%{http_code}" -X GET \
              -H "Authorization: token ${GITEE_TOKEN}" \
              "${BRANCH_API_URL}")
            
            BRANCH_CHECK_HTTP_CODE=$(echo "$BRANCH_CHECK" | tail -n1)
            if [ "$BRANCH_CHECK_HTTP_CODE" = "200" ]; then
              BRANCH_CHECK_BODY=$(echo "$BRANCH_CHECK" | sed '$d')
              TARGET_COMMITISH=$(echo "$BRANCH_CHECK_BODY" | jq -r '.commit.sha // empty' 2>/dev/null || echo "")
              if [ -z "$TARGET_COMMITISH" ] || [ "$TARGET_COMMITISH" == "null" ]; then
                echo "⚠️ 无法获取默认分支的 commit SHA，将使用分支名"
                TARGET_COMMITISH="${REPO_DEFAULT_BRANCH}"
              else
                echo "✅ 使用默认分支 ${REPO_DEFAULT_BRANCH} 的最新 commit: ${TARGET_COMMITISH:0:7}..."
              fi
            else
              echo "⚠️ 无法获取默认分支信息，将使用分支名"
              TARGET_COMMITISH="${REPO_DEFAULT_BRANCH}"
            fi
          fi
          echo ""
          
          # 检查标签是否存在，如果不存在则创建
          echo "🔍 检查 Gitee 标签是否存在..."
          TAG_CHECK_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/tags/${TAG_NAME_ENCODED}"
          echo "  标签检查 API URL: ${TAG_CHECK_API_URL}"
          
          TAG_CHECK=$(curl -s -w "\n%{http_code}" -X GET \
            -H "Authorization: token ${GITEE_TOKEN}" \
            "${TAG_CHECK_API_URL}")
          
          TAG_CHECK_HTTP_CODE=$(echo "$TAG_CHECK" | tail -n1)
          TAG_CHECK_BODY=$(echo "$TAG_CHECK" | sed '$d')
          
          echo "  HTTP 状态码: ${TAG_CHECK_HTTP_CODE}"
          
          if [ "$TAG_CHECK_HTTP_CODE" != "200" ]; then
            echo "⚠️ 标签 ${TAG_NAME} 不存在，创建标签..."
            
            # 创建标签（使用默认分支的最新 commit）
            CREATE_TAG_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/tags"
            echo "  创建标签 API URL: ${CREATE_TAG_API_URL}"
            
            CREATE_TAG_BODY=$(echo "{
              \"refs\": \"${TARGET_COMMITISH}\",
              \"tag_name\": \"${TAG_NAME}\",
              \"message\": \"Release ${TAG_NAME}\"
            }" | jq -c .)
            echo "  请求体: ${CREATE_TAG_BODY}"
            
            CREATE_TAG_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "Authorization: token ${GITEE_TOKEN}" \
              -d "${CREATE_TAG_BODY}" \
              "${CREATE_TAG_API_URL}")
            
            CREATE_TAG_HTTP_CODE=$(echo "$CREATE_TAG_RESPONSE" | tail -n1)
            CREATE_TAG_BODY_RESPONSE=$(echo "$CREATE_TAG_RESPONSE" | sed '$d')
            
            echo "  响应 HTTP 状态码: ${CREATE_TAG_HTTP_CODE}"
            
            if [ "$CREATE_TAG_HTTP_CODE" = "200" ] || [ "$CREATE_TAG_HTTP_CODE" = "201" ]; then
              echo "✅ 标签 ${TAG_NAME} 创建成功"
            else
              ERROR_MSG=$(echo "$CREATE_TAG_BODY_RESPONSE" | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "$CREATE_TAG_BODY_RESPONSE")
              # 如果标签已存在，继续执行
              if echo "$ERROR_MSG" | grep -qi "已存在\|already exists\|duplicate\|标签名已存在"; then
                echo "⚠️ 标签已存在，继续执行..."
              else
                echo "⚠️ 创建标签失败 (HTTP ${CREATE_TAG_HTTP_CODE})，但继续执行"
                echo "  错误信息: ${ERROR_MSG}"
              fi
            fi
          else
            echo "✅ 标签 ${TAG_NAME} 已存在"
          fi
          
          # 检查并删除所有匹配tag的Release（覆盖创建策略）
          echo "🔍 检查并删除所有匹配tag的Gitee Release..."
          DELETED_COUNT=0
          PAGE=1
          PER_PAGE=100
          
          while true; do
            # 获取Release列表
            RELEASES_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases?page=${PAGE}&per_page=${PER_PAGE}"
            RELEASES_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET \
              -H "Authorization: token ${GITEE_TOKEN}" \
              "${RELEASES_API_URL}")
            
            RELEASES_HTTP_CODE=$(echo "$RELEASES_RESPONSE" | tail -n1)
            RELEASES_BODY=$(echo "$RELEASES_RESPONSE" | sed '$d')
            
            if [ "$RELEASES_HTTP_CODE" != "200" ]; then
              echo "⚠️ 获取Release列表失败 (HTTP ${RELEASES_HTTP_CODE})，跳过删除步骤"
              break
            fi
            
            # 解析Release列表，查找匹配tag的Release
            MATCHING_RELEASES=$(echo "$RELEASES_BODY" | jq -r ".[] | select(.tag_name == \"${TAG_NAME}\") | .id" 2>/dev/null || echo "")
            
            if [ -z "$MATCHING_RELEASES" ]; then
              # 当前页没有匹配的Release，检查是否还有下一页
              RELEASE_COUNT=$(echo "$RELEASES_BODY" | jq 'length' 2>/dev/null || echo "0")
              if [ "$RELEASE_COUNT" -lt "$PER_PAGE" ]; then
                break
              fi
              PAGE=$((PAGE + 1))
              continue
            fi
            
            # 删除所有匹配的Release（使用数组避免子shell问题）
            while IFS= read -r RELEASE_ID; do
              if [ -n "$RELEASE_ID" ] && [ "$RELEASE_ID" != "null" ]; then
                echo "  删除 Release ID: ${RELEASE_ID} (tag: ${TAG_NAME})"
                DELETE_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases/${RELEASE_ID}"
                
                DELETE_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE \
                  -H "Authorization: token ${GITEE_TOKEN}" \
                  "${DELETE_API_URL}")
                
                DELETE_HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)
                
                if [ "$DELETE_HTTP_CODE" = "204" ] || [ "$DELETE_HTTP_CODE" = "200" ]; then
                  echo "  ✅ 已删除 Release (ID: ${RELEASE_ID})"
                  DELETED_COUNT=$((DELETED_COUNT + 1))
                else
                  DELETE_BODY=$(echo "$DELETE_RESPONSE" | sed '$d')
                  ERROR_MSG=$(echo "$DELETE_BODY" | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "$DELETE_BODY")
                  echo "  ⚠️ 删除 Release ${RELEASE_ID} 失败 (HTTP ${DELETE_HTTP_CODE}): ${ERROR_MSG}"
                fi
              fi
            done <<< "$MATCHING_RELEASES"
            
            # 检查是否还有下一页
            RELEASE_COUNT=$(echo "$RELEASES_BODY" | jq 'length' 2>/dev/null || echo "0")
            if [ "$RELEASE_COUNT" -lt "$PER_PAGE" ]; then
              break
            fi
            PAGE=$((PAGE + 1))
          done
          
          if [ "$DELETED_COUNT" -gt 0 ]; then
            echo "✅ 共删除了 ${DELETED_COUNT} 个匹配tag的Release"
            # 等待一下，确保删除操作完成
            sleep 3
          else
            echo "✅ 未找到需要删除的Release，将创建新的Release"
          fi
          
          # 创建新 Release（覆盖创建策略：总是创建新的）
          echo ""
          echo "📝 创建新的 Gitee Release..."
          CREATE_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases"
          echo "  创建 API URL: ${CREATE_API_URL}"
          
          # 构建创建请求体
          CREATE_BODY_JSON=$(echo "${RELEASE_BODY}" | jq -Rs .)
          REQUEST_BODY=$(echo "{
            \"tag_name\": \"${TAG_NAME}\",
            \"name\": \"${RELEASE_NAME}\",
            \"body\": ${CREATE_BODY_JSON},
            \"target_commitish\": \"${TARGET_COMMITISH}\",
            \"prerelease\": false
          }" | jq -c .)
          echo "  请求体: ${REQUEST_BODY}"
          
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: token ${GITEE_TOKEN}" \
            -d "${REQUEST_BODY}" \
            "${CREATE_API_URL}")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo "  响应 HTTP 状态码: ${HTTP_CODE}"
          
          # 检查响应
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
            if echo "${RESPONSE_BODY}" | grep -q '"id"'; then
              RELEASE_ID=$(echo "${RESPONSE_BODY}" | jq -r '.id // empty')
              RELEASE_TAG_NAME=$(echo "${RESPONSE_BODY}" | jq -r '.tag_name // empty' 2>/dev/null || echo "")
              RELEASE_CREATED=$(echo "${RESPONSE_BODY}" | jq -r '.created_at // empty' 2>/dev/null || echo "")
              echo "✅ Gitee Release 创建成功"
              echo "  Release ID: ${RELEASE_ID}"
              if [ -n "$RELEASE_TAG_NAME" ]; then
                echo "  标签: ${RELEASE_TAG_NAME}"
              fi
              if [ -n "$RELEASE_CREATED" ]; then
                echo "  创建时间: ${RELEASE_CREATED}"
              fi
            else
              echo "⚠️ 响应格式异常，但 HTTP 状态码为 ${HTTP_CODE}"
              echo "  响应内容: ${RESPONSE_BODY}"
            fi
          else
            ERROR_MSG=$(echo "${RESPONSE_BODY}" | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "${RESPONSE_BODY}")
            echo "❌ Gitee Release 创建失败 (HTTP ${HTTP_CODE})"
            echo "  错误信息: ${ERROR_MSG}"
            echo "  完整响应: ${RESPONSE_BODY}"
            exit 1
          fi

      - name: Upload assets to Gitee Release
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          GITEE_REPO_OWNER: ${{ secrets.GITEE_REPO_OWNER }}
          GITEE_REPO_NAME: ${{ secrets.GITEE_REPO_NAME }}
        run: |
          TAG_NAME="${{ steps.get_version.outputs.TAG_NAME }}"
          
          # 清理并去除换行符、回车符和前后空格
          GITEE_REPO_OWNER=$(printf '%s' "${GITEE_REPO_OWNER}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          GITEE_REPO_NAME=$(printf '%s' "${GITEE_REPO_NAME}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # URL 编码
          GITEE_REPO_OWNER_ENCODED=$(printf '%s' "${GITEE_REPO_OWNER}" | jq -sRr @uri)
          GITEE_REPO_NAME_ENCODED=$(printf '%s' "${GITEE_REPO_NAME}" | jq -sRr @uri)
          TAG_NAME_ENCODED=$(printf '%s' "${TAG_NAME}" | jq -sRr @uri)
          GITEE_REPO="${GITEE_REPO_OWNER}/${GITEE_REPO_NAME}"
          
          echo "📤 上传构建产物到 Gitee Release..."
          echo "  标签: ${TAG_NAME}"
          echo "  仓库: ${GITEE_REPO}"
          echo "  Owner: ${GITEE_REPO_OWNER}"
          echo "  Repo Name: ${GITEE_REPO_NAME}"
          
          # 首先获取 Release ID（用于上传文件）
          echo "🔍 获取 Gitee Release ID..."
          RELEASE_INFO_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases/tags/${TAG_NAME_ENCODED}"
          echo "  API URL: ${RELEASE_INFO_API_URL}"
          
          RELEASE_INFO=$(curl -s -w "\n%{http_code}" -X GET \
            -H "Authorization: token ${GITEE_TOKEN}" \
            "${RELEASE_INFO_API_URL}")
          
          RELEASE_INFO_HTTP_CODE=$(echo "$RELEASE_INFO" | tail -n1)
          RELEASE_INFO_BODY=$(echo "$RELEASE_INFO" | sed '$d')
          
          echo "  HTTP 状态码: ${RELEASE_INFO_HTTP_CODE}"
          
          if [ "$RELEASE_INFO_HTTP_CODE" != "200" ] || ! echo "${RELEASE_INFO_BODY}" | grep -q '"id"'; then
            echo "❌ 无法获取 Gitee Release 信息 (HTTP ${RELEASE_INFO_HTTP_CODE})"
            echo "  API URL: ${RELEASE_INFO_API_URL}"
            echo "  响应: ${RELEASE_INFO_BODY}"
            exit 1
          fi
          
          RELEASE_ID=$(echo "${RELEASE_INFO_BODY}" | jq -r '.id // empty')
          RELEASE_NAME_FROM_API=$(echo "${RELEASE_INFO_BODY}" | jq -r '.name // empty' 2>/dev/null || echo "")
          echo "✅ 找到 Gitee Release"
          echo "  Release ID: ${RELEASE_ID}"
          if [ -n "$RELEASE_NAME_FROM_API" ]; then
            echo "  Release 名称: ${RELEASE_NAME_FROM_API}"
          fi
          
          # 检查文件数量
          FILE_COUNT=$(find release-assets -type f 2>/dev/null | wc -l)
          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "⚠️ 未找到需要上传的文件"
            exit 0
          fi
          
          echo "  找到 ${FILE_COUNT} 个文件需要上传"
          
          # 收集所有文件列表
          FILES=()
          while IFS= read -r -d '' file; do
            FILES+=("$file")
          done < <(find release-assets -type f -print0 2>/dev/null)
          
          TOTAL_FILES=${#FILES[@]}
          UPLOAD_SUCCESS=0
          UPLOAD_FAILED=0
          MAX_RETRIES=3
          RETRY_DELAY=5
          
          # 上传所有文件（带重试机制）
          UPLOAD_API_BASE_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases/${RELEASE_ID}/attach_files"
          echo "  上传 API URL: ${UPLOAD_API_BASE_URL}"
          echo ""
          
          FILE_INDEX=0
          for file in "${FILES[@]}"; do
            FILE_INDEX=$((FILE_INDEX + 1))
            
            # 添加请求间隔，避免 Gitee API 限流（每个文件上传前等待 2 秒）
            if [ $FILE_INDEX -gt 1 ]; then
              echo "   ⏸️  等待 2 秒以避免 API 限流..."
              sleep 2
            fi
            filename=$(basename "$file")
            filesize=$(du -h "$file" | cut -f1)
            filepath=$(realpath "$file" 2>/dev/null || echo "$file")
            filesize_bytes=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "0")
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "📦 [${FILE_INDEX}/${TOTAL_FILES}] 上传 ${filename}"
            echo "   文件大小: ${filesize} (${filesize_bytes} bytes)"
            echo "   文件路径: ${filepath}"
            echo "   整体进度: $((FILE_INDEX * 100 / TOTAL_FILES))% (${FILE_INDEX}/${TOTAL_FILES} 个文件)"
            echo ""
            
            # 重试机制
            RETRY_COUNT=0
            UPLOAD_SUCCESS_FLAG=false
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if [ $RETRY_COUNT -gt 0 ]; then
                echo "   ⏳ 重试第 ${RETRY_COUNT}/${MAX_RETRIES} 次（等待 ${RETRY_DELAY} 秒后重试）..."
                sleep $RETRY_DELAY
              fi
              
              # 使用 curl 上传，显示进度条
              echo "   📤 开始上传 ${filename}..."
              UPLOAD_START_TIME=$(date +%s)
              
              # 创建临时文件存储响应和HTTP状态码
              TEMP_RESPONSE_FILE=$(mktemp)
              TEMP_HTTP_CODE_FILE=$(mktemp)
              
              # 使用 curl 上传
              # --progress-bar: 进度条输出到 stderr（会实时显示，不重定向）
              # -w "%{http_code}": HTTP 状态码输出到 stdout
              # -o: 响应体保存到文件
              # 超时设置说明：
              #   --connect-timeout: 连接超时（30秒，建立连接的时间）
              #   --max-time: 总超时时间（文件大小/100KB/s + 10分钟缓冲，最大60分钟）
              #   注意：Gitee API 实际上传平均速度约 100KB/s，需要根据实际速度设置超时时间
              CONNECT_TIMEOUT=30
              # 计算传输超时：假设平均速度 100KB/s（根据实际观测的上传速度）
              # 加上 10 分钟缓冲时间（600秒），以应对网络波动和服务器处理延迟
              MAX_TIMEOUT=$((filesize_bytes / 102400 + 600))
              if [ $MAX_TIMEOUT -lt 600 ]; then
                MAX_TIMEOUT=600  # 最小 10 分钟
              fi
              if [ $MAX_TIMEOUT -gt 3600 ]; then
                MAX_TIMEOUT=3600  # 最大 60 分钟
              fi
              
              echo "   ⏳ 上传中..."
              echo "   连接超时: ${CONNECT_TIMEOUT}秒"
              echo "   传输超时: ${MAX_TIMEOUT}秒（约 $((MAX_TIMEOUT / 60)) 分钟）"
              echo "   文件大小: ${filesize} (${filesize_bytes} bytes)"
              echo ""
              
              # curl 进度条输出到 stderr（不重定向，实时显示）
              # HTTP 状态码保存到文件（只重定向 stdout）
              # 响应体通过 -o 保存到文件
              # 使用 --retry 和 --retry-delay 处理临时网络错误
              curl --progress-bar --show-error \
                --connect-timeout ${CONNECT_TIMEOUT} \
                --max-time ${MAX_TIMEOUT} \
                --retry 2 \
                --retry-delay 3 \
                --retry-connrefused \
                -w "%{http_code}" \
                -o "${TEMP_RESPONSE_FILE}" \
                -X POST \
                -H "Authorization: token ${GITEE_TOKEN}" \
                -F "file=@${file}" \
                "${UPLOAD_API_BASE_URL}" \
                > "${TEMP_HTTP_CODE_FILE}"
              
              CURL_EXIT_CODE=$?
              
              echo ""
              
              # 读取 HTTP 状态码
              HTTP_CODE=$(cat "${TEMP_HTTP_CODE_FILE}" 2>/dev/null | grep -oE '[0-9]{3}' | tail -n1 || echo "")
              
              # 读取响应体
              RESPONSE_BODY=$(cat "${TEMP_RESPONSE_FILE}" 2>/dev/null || echo "")
              
              # 清理临时文件
              rm -f "${TEMP_RESPONSE_FILE}" "${TEMP_HTTP_CODE_FILE}"
              
              UPLOAD_END_TIME=$(date +%s)
              UPLOAD_DURATION=$((UPLOAD_END_TIME - UPLOAD_START_TIME))
              
              # 检查 curl 退出码
              if [ $CURL_EXIT_CODE -eq 28 ]; then
                echo "   ❌ 上传超时（超过 ${MAX_TIMEOUT} 秒）"
                HTTP_CODE="TIMEOUT"
              elif [ $CURL_EXIT_CODE -ne 0 ]; then
                echo "   ⚠️ curl 退出码: ${CURL_EXIT_CODE}"
              fi
              
              echo "   ✅ 上传完成（耗时: ${UPLOAD_DURATION}秒）"
              
              echo ""
              echo "   HTTP 状态码: ${HTTP_CODE}"
              echo "   上传耗时: ${UPLOAD_DURATION} 秒"
              
              # 检查上传结果
              if [ "$HTTP_CODE" -eq 201 ] || [ "$HTTP_CODE" -eq 200 ]; then
                echo "   ✅ ${filename} 上传成功"
                UPLOAD_SUCCESS=$((UPLOAD_SUCCESS + 1))
                UPLOAD_SUCCESS_FLAG=true
                break
              elif echo "$RESPONSE_BODY" | grep -qi "already exists\|已存在\|duplicate"; then
                echo "   ⚠️ ${filename} 已存在，跳过"
                UPLOAD_SUCCESS=$((UPLOAD_SUCCESS + 1))
                UPLOAD_SUCCESS_FLAG=true
                break
              else
                ERROR_MSG=$(echo "$RESPONSE_BODY" | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "HTTP ${HTTP_CODE}")
                echo "   ❌ 上传失败: ${ERROR_MSG}"
                
                # 检查是否是可重试的错误
                if echo "$HTTP_CODE" | grep -qE "^(429|500|502|503|504)$"; then
                  echo "   ℹ️  检测到可重试的错误（HTTP ${HTTP_CODE}），将重试"
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                elif [ "$HTTP_CODE" -eq 401 ] || [ "$HTTP_CODE" -eq 403 ]; then
                  echo "   ❌ 认证失败（HTTP ${HTTP_CODE}），无法重试"
                  break
                elif [ "$HTTP_CODE" -eq 404 ]; then
                  echo "   ❌ Release 不存在（HTTP ${HTTP_CODE}），无法重试"
                  break
                else
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                fi
              fi
            done
            
            if [ "$UPLOAD_SUCCESS_FLAG" = false ]; then
              echo "   ❌ ${filename} 上传失败（已重试 ${MAX_RETRIES} 次）"
              echo "   完整响应: ${RESPONSE_BODY}"
              UPLOAD_FAILED=$((UPLOAD_FAILED + 1))
            fi
            
            echo ""
          done
          
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "📊 上传统计:"
          echo "  ✅ 成功: ${UPLOAD_SUCCESS}/${TOTAL_FILES}"
          echo "  ❌ 失败: ${UPLOAD_FAILED}/${TOTAL_FILES}"
          echo "  完成率: $((UPLOAD_SUCCESS * 100 / TOTAL_FILES))%"
          
          if [ "$UPLOAD_FAILED" -gt 0 ]; then
            echo ""
            echo "⚠️ 部分文件上传失败"
            if [ "$UPLOAD_FAILED" -eq "$TOTAL_FILES" ]; then
              echo "❌ 所有文件上传失败，终止流程"
              exit 1
            else
              echo "⚠️ 继续执行后续步骤"
            fi
          else
            echo "✅ 所有构建产物上传完成"
          fi

      - name: Sync update config to Gitee
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          GITEE_REPO_OWNER: ${{ secrets.GITEE_REPO_OWNER }}
          GITEE_REPO_NAME: ${{ secrets.GITEE_REPO_NAME }}
        run: |
          echo "🔄 同步更新配置到 Gitee..."
          
          # 清理并去除换行符、回车符和前后空格
          GITEE_REPO_OWNER=$(printf '%s' "${GITEE_REPO_OWNER}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          GITEE_REPO_NAME=$(printf '%s' "${GITEE_REPO_NAME}" | tr -d '\n\r\t' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          GITEE_REPO="${GITEE_REPO_OWNER}/${GITEE_REPO_NAME}"
          TAG_NAME="${{ steps.get_version.outputs.TAG_NAME }}"
          
          echo "  Owner: ${GITEE_REPO_OWNER}"
          echo "  Repo Name: ${GITEE_REPO_NAME}"
          echo "  仓库: ${GITEE_REPO}"
          
          # URL 编码
          GITEE_REPO_OWNER_ENCODED=$(printf '%s' "${GITEE_REPO_OWNER}" | jq -sRr @uri)
          GITEE_REPO_NAME_ENCODED=$(printf '%s' "${GITEE_REPO_NAME}" | jq -sRr @uri)
          
          # 从 Release 下载的配置文件中读取（应该已经在 release-assets 目录中）
          if [ -f "release-assets/update_config_github.json" ]; then
            # 复制到当前目录以便后续处理
            cp release-assets/update_config_github.json update_config_github.json
            echo "✅ 从 Release 中找到配置文件"
          elif [ -f "update_config_github.json" ]; then
            echo "✅ 找到配置文件（备用位置）"
          fi
          
          if [ -f "update_config_github.json" ]; then
            echo "✅ 找到 GitHub 更新配置文件"
            echo "  文件路径: $(realpath update_config_github.json 2>/dev/null || echo 'update_config_github.json')"
            
            # 显示原始配置内容
            echo "  原始配置内容:"
            cat update_config_github.json | jq '.' 2>/dev/null || cat update_config_github.json
            
            # 转换为 Gitee 格式
            echo ""
            echo "  转换配置为 Gitee 格式..."
            echo "  Gitee 仓库: ${GITEE_REPO}"
            
            # 固定 Release Tag 名称（简短，无特殊字符）
            CONFIG_RELEASE_TAG="config"
            CONFIG_RELEASE_TAG_ENCODED=$(printf '%s' "${CONFIG_RELEASE_TAG}" | jq -sRr @uri)
            
            # 使用 jq 修改 URL，updateCheckUrl 指向固定 Release
            cat update_config_github.json | jq "
              .updateCheckUrl = \"https://gitee.com/${GITEE_REPO}/releases/download/${CONFIG_RELEASE_TAG}/update_config_gitee.json\" |
              .client.platforms.macos.downloadUrl = (.client.platforms.macos.downloadUrl | gsub(\"github.com.*releases\"; \"gitee.com/${GITEE_REPO}/releases\")) |
              .client.platforms.windows.downloadUrl = (.client.platforms.windows.downloadUrl | gsub(\"github.com.*releases\"; \"gitee.com/${GITEE_REPO}/releases\")) |
              .server.platforms.android.downloadUrl = (.server.platforms.android.downloadUrl | gsub(\"github.com.*releases\"; \"gitee.com/${GITEE_REPO}/releases\"))
            " > update_config_gitee.json
            
            echo "✅ 已生成 Gitee 更新配置文件"
            echo "  文件路径: $(realpath update_config_gitee.json 2>/dev/null || echo 'update_config_gitee.json')"
            echo "  更新检查 URL: https://gitee.com/${GITEE_REPO}/releases/download/${CONFIG_RELEASE_TAG}/update_config_gitee.json"
            echo ""
            echo "  Gitee 配置内容:"
            cat update_config_gitee.json | jq '.' 2>/dev/null || cat update_config_gitee.json
            
            # 获取 master 分支的最新 commit SHA（用于创建/更新 Release）
            echo ""
            echo "🔍 获取 master 分支的最新 commit..."
            BRANCH_INFO=$(curl -s -X GET \
              -H "Authorization: token ${GITEE_TOKEN}" \
              "https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/branches/master")
            
            MASTER_COMMIT_SHA=$(echo "$BRANCH_INFO" | jq -r '.commit.sha // empty' 2>/dev/null || echo "")
            
            if [ -z "$MASTER_COMMIT_SHA" ] || [ "$MASTER_COMMIT_SHA" == "null" ]; then
              echo "⚠️ 无法获取 master 分支的 commit SHA，使用默认分支"
              MASTER_COMMIT_SHA="master"
            else
              echo "✅ Master 分支最新 commit: ${MASTER_COMMIT_SHA:0:7}..."
            fi
            
            # 检查配置 Release 是否存在
            echo ""
            echo "🔍 检查配置 Release 是否存在..."
            RELEASE_CHECK=$(curl -s -w "\n%{http_code}" -X GET \
              -H "Authorization: token ${GITEE_TOKEN}" \
              "https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases/tags/${CONFIG_RELEASE_TAG_ENCODED}")
            
            RELEASE_CHECK_HTTP_CODE=$(echo "$RELEASE_CHECK" | tail -n1)
            RELEASE_CHECK_BODY=$(echo "$RELEASE_CHECK" | sed '$d')
            
            echo "  HTTP 状态码: ${RELEASE_CHECK_HTTP_CODE}"
            
            if [ "$RELEASE_CHECK_HTTP_CODE" = "200" ]; then
              RELEASE_ID=$(echo "$RELEASE_CHECK_BODY" | jq -r '.id // empty' 2>/dev/null || echo "")
              if [ -n "$RELEASE_ID" ] && [ "$RELEASE_ID" != "null" ]; then
                echo "✅ Release ${CONFIG_RELEASE_TAG} 已存在 (ID: ${RELEASE_ID})"
                USE_EXISTING_RELEASE=true
              else
                echo "⚠️ 无法获取 Release ID，将创建新的 Release"
                USE_EXISTING_RELEASE=false
              fi
            else
              echo "⚠️ Release ${CONFIG_RELEASE_TAG} 不存在，将创建新的 Release"
              USE_EXISTING_RELEASE=false
            fi
            
            # 确保 tag 存在（Release 需要 tag）
            echo ""
            echo "🔍 确保 Tag ${CONFIG_RELEASE_TAG} 存在..."
            TAG_CHECK=$(curl -s -w "\n%{http_code}" -X GET \
              -H "Authorization: token ${GITEE_TOKEN}" \
              "https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/tags/${CONFIG_RELEASE_TAG_ENCODED}")
            
            TAG_CHECK_HTTP_CODE=$(echo "$TAG_CHECK" | tail -n1)
            
            if [ "$TAG_CHECK_HTTP_CODE" != "200" ]; then
              echo "  Tag 不存在，创建 Tag..."
              CREATE_TAG_BODY=$(echo "{
                \"refs\": \"${MASTER_COMMIT_SHA}\",
                \"tag_name\": \"${CONFIG_RELEASE_TAG}\",
                \"message\": \"Tag for update config release\"
              }" | jq -c .)
              
              CREATE_TAG_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                -H "Content-Type: application/json" \
                -H "Authorization: token ${GITEE_TOKEN}" \
                -d "${CREATE_TAG_BODY}" \
                "https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/tags")
              
              CREATE_TAG_HTTP_CODE=$(echo "$CREATE_TAG_RESPONSE" | tail -n1)
              
              if [ "$CREATE_TAG_HTTP_CODE" = "200" ] || [ "$CREATE_TAG_HTTP_CODE" = "201" ]; then
                echo "✅ Tag ${CONFIG_RELEASE_TAG} 创建成功"
              else
                ERROR_MSG=$(echo "$CREATE_TAG_RESPONSE" | sed '$d' | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "")
                if echo "$ERROR_MSG" | grep -qi "已存在\|already exists\|duplicate\|标签名已存在"; then
                  echo "✅ Tag 已存在"
                else
                  echo "⚠️ Tag 创建失败，但继续执行"
                fi
              fi
            else
              echo "✅ Tag ${CONFIG_RELEASE_TAG} 已存在"
            fi
            
            # 覆盖创建 Release（如果存在则先删除）
            echo ""
            if [ "$USE_EXISTING_RELEASE" = true ] && [ -n "$RELEASE_ID" ] && [ "$RELEASE_ID" != "null" ]; then
              echo "🗑️  删除现有配置 Release (ID: ${RELEASE_ID})..."
              
              DELETE_RELEASE_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE \
                -H "Authorization: token ${GITEE_TOKEN}" \
                "https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases/${RELEASE_ID}")
              
              DELETE_RELEASE_HTTP_CODE=$(echo "$DELETE_RELEASE_RESPONSE" | tail -n1)
              
              echo "  删除响应 HTTP 状态码: ${DELETE_RELEASE_HTTP_CODE}"
              
              if [ "$DELETE_RELEASE_HTTP_CODE" = "204" ] || [ "$DELETE_RELEASE_HTTP_CODE" = "200" ]; then
                echo "✅ 已删除现有配置 Release"
                # 等待一下，确保删除操作完成
                sleep 2
              else
                ERROR_MSG=$(echo "$DELETE_RELEASE_RESPONSE" | sed '$d' | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "")
                echo "⚠️ 删除现有 Release 失败 (HTTP ${DELETE_RELEASE_HTTP_CODE})，但继续创建新 Release"
                echo "  错误信息: ${ERROR_MSG}"
              fi
            fi
            
            # 创建新 Release（覆盖创建策略：总是创建新的）
            echo ""
            echo "📝 创建配置 Release..."
            
            # 使用和 GitHub 一样的固定 release 名字
            RELEASE_NAME="UpdateConfig"
            RELEASE_BODY="This release contains the update configuration file for the application."
            
            CREATE_RELEASE_BODY=$(echo "{
              \"tag_name\": \"${CONFIG_RELEASE_TAG}\",
              \"name\": \"${RELEASE_NAME}\",
              \"body\": \"${RELEASE_BODY}\",
              \"target_commitish\": \"${MASTER_COMMIT_SHA}\",
              \"prerelease\": false
            }" | jq -c .)
            
            CREATE_RELEASE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "Authorization: token ${GITEE_TOKEN}" \
              -d "${CREATE_RELEASE_BODY}" \
              "https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases")
            
            CREATE_RELEASE_HTTP_CODE=$(echo "$CREATE_RELEASE_RESPONSE" | tail -n1)
            CREATE_RELEASE_BODY_RESPONSE=$(echo "$CREATE_RELEASE_RESPONSE" | sed '$d')
            
            echo "  响应 HTTP 状态码: ${CREATE_RELEASE_HTTP_CODE}"
            
            if [ "$CREATE_RELEASE_HTTP_CODE" = "200" ] || [ "$CREATE_RELEASE_HTTP_CODE" = "201" ]; then
              RELEASE_ID=$(echo "$CREATE_RELEASE_BODY_RESPONSE" | jq -r '.id // empty' 2>/dev/null || echo "")
              if [ -z "$RELEASE_ID" ] || [ "$RELEASE_ID" == "null" ]; then
                echo "❌ 无法从响应中获取 Release ID"
                echo "  响应内容: ${CREATE_RELEASE_BODY_RESPONSE}"
                exit 1
              fi
              echo "✅ Release 创建成功 (ID: ${RELEASE_ID})"
            else
              ERROR_MSG=$(echo "$CREATE_RELEASE_BODY_RESPONSE" | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "$CREATE_RELEASE_BODY_RESPONSE")
              echo "❌ Release 创建失败 (HTTP ${CREATE_RELEASE_HTTP_CODE})"
              echo "  错误信息: ${ERROR_MSG}"
              exit 1
            fi
            
            # 上传配置文件到 Release
            echo ""
            echo "📤 上传配置文件到 Release..."
            
            # 检查文件是否已存在
            ASSETS_CHECK=$(curl -s -X GET \
              -H "Authorization: token ${GITEE_TOKEN}" \
              "https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases/${RELEASE_ID}/attach_files")
            
            EXISTING_ASSET_ID=$(echo "$ASSETS_CHECK" | jq -r ".[] | select(.name == \"update_config_gitee.json\") | .id" 2>/dev/null | head -1)
            
            if [ -n "$EXISTING_ASSET_ID" ] && [ "$EXISTING_ASSET_ID" != "null" ]; then
              echo "  文件已存在 (ID: ${EXISTING_ASSET_ID})，删除旧文件..."
              DELETE_ASSET_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE \
                -H "Authorization: token ${GITEE_TOKEN}" \
                "https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases/${RELEASE_ID}/attach_files/${EXISTING_ASSET_ID}")
              
              DELETE_ASSET_HTTP_CODE=$(echo "$DELETE_ASSET_RESPONSE" | tail -n1)
              echo "  删除响应 HTTP 状态码: ${DELETE_ASSET_HTTP_CODE}"
              sleep 2
            fi
            
            echo "  上传新文件..."
            UPLOAD_API_URL="https://gitee.com/api/v5/repos/${GITEE_REPO_OWNER_ENCODED}/${GITEE_REPO_NAME_ENCODED}/releases/${RELEASE_ID}/attach_files"
            
            FILE_SIZE=$(stat -f%z update_config_gitee.json 2>/dev/null || stat -c%s update_config_gitee.json 2>/dev/null || echo "unknown")
            FILE_SIZE_BYTES=$(stat -f%z update_config_gitee.json 2>/dev/null || stat -c%s update_config_gitee.json 2>/dev/null || echo "0")
            echo "  文件大小: ${FILE_SIZE} (${FILE_SIZE_BYTES} bytes)"
            
            # 重试机制
            MAX_RETRIES=3
            RETRY_DELAY=5
            RETRY_COUNT=0
            UPLOAD_SUCCESS_FLAG=false
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if [ $RETRY_COUNT -gt 0 ]; then
                echo "  ⏳ 重试第 ${RETRY_COUNT}/${MAX_RETRIES} 次（等待 ${RETRY_DELAY} 秒后重试）..."
                sleep $RETRY_DELAY
              fi
              
              echo "  📤 开始上传..."
              UPLOAD_START_TIME=$(date +%s)
              
              # 创建临时文件存储响应和HTTP状态码
              TEMP_RESPONSE_FILE=$(mktemp)
              TEMP_HTTP_CODE_FILE=$(mktemp)
              
              # 配置文件通常较小，但仍需要足够的超时时间
              CONNECT_TIMEOUT=30
              MAX_TIMEOUT=600  # 配置文件上传超时 10 分钟
              
              echo ""
              echo "   连接超时: ${CONNECT_TIMEOUT}秒"
              echo "   传输超时: ${MAX_TIMEOUT}秒"
              
              # 使用 curl 上传
              # --progress-bar: 进度条输出到 stderr（会实时显示，不重定向）
              # -w "%{http_code}": HTTP 状态码输出到 stdout
              # -o: 响应体保存到文件
              # 使用 --retry 和 --retry-delay 处理临时网络错误
              # 注意：只重定向 stdout 到文件，stderr（进度条）直接输出到终端
              curl --progress-bar --show-error \
                --connect-timeout ${CONNECT_TIMEOUT} \
                --max-time ${MAX_TIMEOUT} \
                --retry 2 \
                --retry-delay 3 \
                --retry-connrefused \
                -w "%{http_code}" \
                -o "${TEMP_RESPONSE_FILE}" \
                -X POST \
                -H "Authorization: token ${GITEE_TOKEN}" \
                -F "file=@update_config_gitee.json" \
                -F "name=update_config_gitee.json" \
                "${UPLOAD_API_URL}" \
                > "${TEMP_HTTP_CODE_FILE}"
              
              CURL_EXIT_CODE=$?
              
              echo ""
              
              # 读取 HTTP 状态码
              UPLOAD_HTTP_CODE=$(cat "${TEMP_HTTP_CODE_FILE}" 2>/dev/null | grep -oE '[0-9]{3}' | tail -n1 || echo "")
              
              # 读取响应体
              UPLOAD_BODY_RESPONSE=$(cat "${TEMP_RESPONSE_FILE}" 2>/dev/null || echo "")
              
              # 清理临时文件
              rm -f "${TEMP_RESPONSE_FILE}" "${TEMP_HTTP_CODE_FILE}"
              
              UPLOAD_END_TIME=$(date +%s)
              UPLOAD_DURATION=$((UPLOAD_END_TIME - UPLOAD_START_TIME))
              
              # 检查 curl 退出码
              if [ $CURL_EXIT_CODE -ne 0 ]; then
                echo "  ⚠️ curl 退出码: ${CURL_EXIT_CODE}"
              fi
              
              echo ""
              echo "  响应 HTTP 状态码: ${UPLOAD_HTTP_CODE}"
              echo "  上传耗时: ${UPLOAD_DURATION} 秒"
              
              if [ "$UPLOAD_HTTP_CODE" = "200" ] || [ "$UPLOAD_HTTP_CODE" = "201" ]; then
                ASSET_NAME=$(echo "$UPLOAD_BODY_RESPONSE" | jq -r '.name // empty' 2>/dev/null || echo "")
                ASSET_URL=$(echo "$UPLOAD_BODY_RESPONSE" | jq -r '.browser_download_url // empty' 2>/dev/null || echo "")
                echo "✅ 文件上传成功"
                if [ -n "$ASSET_NAME" ]; then
                  echo "  文件名: ${ASSET_NAME}"
                fi
                if [ -n "$ASSET_URL" ]; then
                  echo "  下载 URL: ${ASSET_URL}"
                fi
                UPLOAD_SUCCESS_FLAG=true
                break
              else
                ERROR_MSG=$(echo "$UPLOAD_BODY_RESPONSE" | jq -r '.message // .error // "未知错误"' 2>/dev/null || echo "HTTP ${UPLOAD_HTTP_CODE}")
                echo "  ❌ 上传失败: ${ERROR_MSG}"
                
                # 检查是否是可重试的错误
                if echo "$UPLOAD_HTTP_CODE" | grep -qE "^(429|500|502|503|504)$"; then
                  echo "  ℹ️  检测到可重试的错误（HTTP ${UPLOAD_HTTP_CODE}），将重试"
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                elif [ "$UPLOAD_HTTP_CODE" -eq 401 ] || [ "$UPLOAD_HTTP_CODE" -eq 403 ]; then
                  echo "  ❌ 认证失败（HTTP ${UPLOAD_HTTP_CODE}），无法重试"
                  break
                elif [ "$UPLOAD_HTTP_CODE" -eq 404 ]; then
                  echo "  ❌ Release 不存在（HTTP ${UPLOAD_HTTP_CODE}），无法重试"
                  break
                else
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                fi
              fi
            done
            
            if [ "$UPLOAD_SUCCESS_FLAG" = false ]; then
              echo ""
              echo "❌ 配置文件上传失败（已重试 ${MAX_RETRIES} 次）"
              echo "  完整响应: ${UPLOAD_BODY_RESPONSE}"
              exit 1
            fi
            
            echo ""
            echo "✅ 更新配置文件已成功同步到 Gitee Release: ${CONFIG_RELEASE_TAG}"
            echo "  访问 URL: https://gitee.com/${GITEE_REPO}/releases/download/${CONFIG_RELEASE_TAG}/update_config_gitee.json"
          else
            echo "⚠️ update_config_github.json 未找到，跳过配置同步"
            echo "  当前目录: $(pwd)"
            echo "  文件列表:"
            ls -la *.json 2>/dev/null || echo "  未找到 JSON 文件"
            exit 1
          fi

